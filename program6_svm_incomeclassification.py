# -*- coding: utf-8 -*-
"""Program6_SVM_IncomeClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mHxyjNFTPqDcWn_xwbaZWJoh9XMS-bOM

### Program 6: Write a python program to predict income levels of adult individuals using Support Vector Machine Model.
The process includes training, testing and evaluating the model on the Adult dataset. In this experiment you need to train a classifier on the Adult dataset, to predict whether an individual’s income is
greater or less than $50,000.



Dataset: We have used a smaller version of adult income dataset. This dataset has 3574 rows and 7 columns.
It has a total of 15 columns, Target Column is "Income", The income is divide into two classes: <=50K and >50K Number of attributes: 6, These are the demographics and other features to describe a person

6 attributes are:

- Age.
- Workclass.
- Education Number of Years.
- Occupation.
- gender.
- Hours-per-week.

The dataset contains missing values that are marked with a question mark character (?). There are two class values ‘>50K‘ and ‘<=50K‘ in target column i.e., it is a binary classification task.
"""

#Required imports
import numpy as np
import pandas as pd

#Read dataset
df = pd.read_csv("smaller_adult.csv")









# See the columns that contain a "?" and how many "?" are there in those columns
df.isin(['?']).sum()

df.columns

#Replace ? with NaN
df['workclass'] = df['workclass'].replace('?', np.nan)
df['occupation'] = df['occupation'].replace('?', np.nan)

#Now the ? has been replaced by NaN, so count of ? is 0
df.isin(['?']).sum()

#Check missing values - NaN values

#Drop all rows that contain a missing value
df.dropna(how='any', inplace=True)

#Check duplicate values in dataframe now
print(f"There are {df.duplicated().sum()} duplicate values")

df = df.drop_duplicates()
df.shape



#Extract X and y from the dataframe , income column is the target column, rest columns are features
X = df.loc[:,['age', 'workclass', 'educational-num', 'occupation', 'gender', 'hours-per-week']]
y = df.loc[:,'income']

# Since y is a binary categorical column we will use label encoder to convert it into numerical columns with values 0 and 1
from sklearn.preprocessing import LabelEncoder
y = LabelEncoder().fit_transform(y)
y = pd.DataFrame(y)
y.head()

#First identify caterogical features and numeric features
numeric_features = X.select_dtypes('number')
categorical_features = X.select_dtypes('object')
categorical_features

numeric_features

#Convert categorical features into numeric
converted_categorical_features = pd.get_dummies(categorical_features)
converted_categorical_features.shape

#combine the converted categorical features and the numeric features together into a new dataframe called "newX"
all_features = [converted_categorical_features, numeric_features]
newX = pd.concat(all_features,axis=1, join='inner')
newX.shape



#Do a train test split
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(newX, y, test_size=0.33, random_state=42)

# Load Support Vector Machine Classifier
from sklearn.svm import SVC
clf = SVC(kernel="linear", gamma = 'auto')
clf.fit(X_train, y_train.values.ravel())

# Make predictions
y_pred = clf.predict(X_test)

predictions_df = pd.DataFrame()
predictions_df['precdicted_salary_class'] = y_pred
predictions_df['actual_salary_class'] = y_test[0].values
predictions_df

#Evaluate the performance of fitting
from sklearn.metrics import accuracy_score
print(accuracy_score(y_pred,y_test))

